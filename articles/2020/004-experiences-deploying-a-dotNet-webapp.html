<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <link rel="icon" href="https://blog.abraham-v.com/theme/images/favicon.ico" />
  <link rel="stylesheet" href="https://blog.abraham-v.com/theme/css/reset.css" />
  <link rel="stylesheet" href="https://blog.abraham-v.com/theme/css/pygments.css" />
  <link rel="stylesheet" href="https://blog.abraham-v.com/theme/css/style.css" />
  <title>Abraham Varricatt</title>
</head>
<body>
  <div class="page">

    <div class="site-glance site-glance-top">
      <header>
        <h1><a href="https://blog.abraham-v.com/">Abraham Varricatt</a></h1>
        <h2>Note To Self</h2>
        <hr />
      </header>
    </div>

    <div class="articles">
  <article>
    <header>
      <h1><a href="https://blog.abraham-v.com/articles/2020/004-experiences-deploying-a-dotNet-webapp.html">Experiences deploying a dotNet web&nbsp;application</a></h1>
      <h2>posted on<time datetime="2020-05-05T00:00:00-04:00"> 2020/05&#8209;May/05</time></h2>
    </header>
    <section><p>Someone I know had lamented on how difficult he found it to manage a dotNet
application online; i.e. a webapp running on Microsoft&#8217;s dotNet Core
technology. It got me pondering - is it really that hard to run dotNet on an
Ubuntu box? At a fundamental level, we are still dealing with managing running
processes/threads in an operating system. So I challenged myself to provision
just such a system! This post mentions some of the memorable moments I had in
accomplishing that&nbsp;challenge.</p>

<div class="section" id="what-was-the-objective">
<h2>What was the objective?<a class="headerlink" href="#what-was-the-objective" title="Permalink to this headline">&nbsp;#</a></h2>
<p>Managing a web-application online is at its core, an operations issue. It is
not a trivial matter to keep a server updated, secure and always accessible.
There are scaling concerns with how to handling load spikes, provisioning
additional systems &#8230; etc. To concern myself with all that would be a
full-time job and not something I wanted to do as a&nbsp;side-activity.</p>
<p>The objective here was to learn what it would take to provision a dotNet webapp
server from scratch. i.e. to find out the exact sequence of steps required from
the moment a host system is rented to the point when it can receive and respond
to network requests. Most importantly, to record those steps in a repeatable
and precise&nbsp;manner.</p>
<p>To keep things simple, it would be acceptable for the server to respond to
web-browser requests from it&#8217;s <span class="caps">IP</span> address. i.e. I did not want to deal with <span class="caps">DNS</span>&nbsp;concerns.</p>
</div>
<div class="section" id="where-is-the-solution">
<h2>Where is the solution?<a class="headerlink" href="#where-is-the-solution" title="Permalink to this headline">&nbsp;#</a></h2>
<p>I wrote all the provisioning scripts in Ansible, saved it to a Github
repository and configured CircleCI to run those steps on a remote droplet
rented from Digital Ocean. Here is the source&nbsp;code,</p>
<p><a class="reference external" href="https://github.com/abrahamvarricatt/droplet_provisioner">https://github.com/abrahamvarricatt/droplet_provisioner</a></p>
<div class="section" id="challenge-01-running-ansible-on-circleci">
<h3>Challenge #01: Running Ansible on CircleCI<a class="headerlink" href="#challenge-01-running-ansible-on-circleci" title="Permalink to this headline">&nbsp;#</a></h3>
<p>CircleCI containers do not come with Ansible installed. My first solution was
to just install ansible as part of the CircleCI deployment script. It worked ..
but added almost half a minute to my deployment time. Could things be faster?
Turns out,&nbsp;yes.</p>
<p>CircleCI allows us to configure custom docker images on which the deployment
scripts would be run. After verifiying that I could pull the official Ubuntu
image, I built my own Dockerfile with ansbile installed, uploaded it to Docker
Hub as a public image and was able to use it as the container for my deployment&nbsp;scripts!</p>
<p>If needed, CircleCI can be configured to use private images, but a free public
image works for my&nbsp;purposes.</p>
</div>
<div class="section" id="challenge-02-server-authentication">
<h3>Challenge #02: Server authentication<a class="headerlink" href="#challenge-02-server-authentication" title="Permalink to this headline">&nbsp;#</a></h3>
<p>Ansible scripts connect to remote hosts via <span class="caps">SSH</span>, which meant I could either use
password-based authentication or an <span class="caps">SSH</span> private-public key pair. Digital Ocean
allows me to create droplets with an intial randomly generated password which
needs to be changed after the first log-in. I was pleasantly surprised that
they also supported creating droplets with <span class="caps">SSH</span> key-pairs. How it works, is that
I would need to upload a public key to them and ask for it to be included on
the host during droplet creation. After the droplet is created, I would be able
to log into the box using my private&nbsp;key.</p>
<p>The idea of uploading the private key to a public Github repository did not sit
well with me. Thankfully, the option to store the key on CircleCI exists. For
this to work, I needed to trust CircleCI with the private key and upload it to
their servers linked to my project. Then as part of the deployment script,
mention that the <span class="caps">SSH</span> key would need to be&nbsp;accessible.</p>
<p>The final part of authentication was storing where the <span class="caps">IP</span> address of my server
would be saved to. For the time being, I decided to just store it publicly as
part of the Github repository. If it needs to be hidden, it can be saved as an
environment variable on&nbsp;CircleCI.</p>
</div>
<div class="section" id="challenge-03-supporting-two-versions-of-dotnet-runtime">
<h3>Challenge #03: Supporting two versions of dotNet runtime<a class="headerlink" href="#challenge-03-supporting-two-versions-of-dotnet-runtime" title="Permalink to this headline">&nbsp;#</a></h3>
<p>I planned to run two separate dotNet projects - one a webapp and another a
background worker. Since there was no plan to actually learn dotNet
programming, I decided to copy-paste code from online tutorials. The issue was
that the code I found for both projects relied on two separate versions of&nbsp;dotNet.</p>
<p>Comparing this to how Python runtimes are handled, I expected this to be a
challenge to setup. Turns out, it isn&#8217;t the case. It was pointed out to me that
multiple versions of dotNet can co-exist on the same system and that they would
figure out between themselves which to run what&nbsp;app.</p>
<p>Which meant that while this wasn&#8217;t a challenge I needed to solve, it was an
instance of me getting stuck due to not knowing how things&nbsp;worked.</p>
</div>
<div class="section" id="challenge-04-installing-the-entity-framework">
<h3>Challenge #04: Installing the Entity Framework<a class="headerlink" href="#challenge-04-installing-the-entity-framework" title="Permalink to this headline">&nbsp;#</a></h3>
<p>The Entity Framework is a dotNet tool to help manage databases. The trouble I
had was that it kept getting installed on the root account of my droplet. No
matter what I tried, it stubbornly refused to work with the webapp user that
was created. The most bizzare thing about this was that when installing the
tool as the webapp user, dotNet would report that it was already installed!
Running it, threw permission issues about how the webapp user account was not
allowed to access it&#8217;s&nbsp;folders.</p>
<p>I traced this issue all the way back to how the dotNet runtime registers itself
to user accounts on an Ubuntu system. It assumes that one is using the bash
shell and appends an entry to the user&#8217;s <span class="caps">PATH</span>. The webapp user was not
configured to use the bash shell by default, which caused the dotNet runtime to
mis-understand the&nbsp;situation.</p>
<p>After setting the default shell of the webapp user to <tt class="docutils literal">/bin/bash</tt> things
began to work as&nbsp;expected.</p>
<p>This was perhaps the most challenging issue about the entire&nbsp;process.</p>
</div>
</div>
</section>
  </article>
  <hr />

    <div class="paginator">
        <a class="previous" href="https://blog.abraham-v.com/articles/2020/003-showing-asterisks-in-terminal.html">&laquo; Older post</a>

        <a class="next" href="https://blog.abraham-v.com/articles/2020/005-differences-between-pyenv-and-pipx.html">Newer post &raquo;</a>
    </div>


    </div>

    <div class="site-glance site-glance-bottom">
      <nav>
        <p><a href="https://blog.abraham-v.com/archives.html">ARCHIVES</a></p>
          <p><a href="https://blog.abraham-v.com/pages/about-me.html">About&nbsp;me</a></p>
      </nav>
    </div>
  </div>
</body>
</html>